#
# This code is mainly generated by Bing AI.
#

import cv2
import numpy as np
import cmapy

def draw_colorbar(dst, cmap, min_value, max_value, orientation='vertical', position='right', 
                  size=0.1, margin=10, font=cv2.FONT_HERSHEY_SIMPLEX, font_scale=1, 
                  font_color=(0, 0, 0), thickness=1, num_ticks=5, tick_length=10, 
                  tick_color=(0, 0, 0)):
    
    # Validate the parameters
    assert dst.dtype == np.uint8, 'image must be np.uint8 type'
    # assert cmap in cmapy.cmap.names(), 'cmap must be a valid cmapy colormap name'
    assert min_value >= 0 and min_value <= 255, 'min_value must be in range [0, 255]'
    assert max_value >= 0 and max_value <= 255, 'max_value must be in range [0, 255]'
    assert min_value < max_value, 'min_value must be less than max_value'
    assert orientation in ['vertical', 'horizontal'], 'orientation must be either vertical or horizontal'
    assert position in ['right', 'left', 'top', 'bottom'], 'position must be either right, left, top, or bottom'
    assert size > 0 and size < 1, 'size must be a fraction between 0 and 1'
    assert margin >= 0, 'margin must be non-negative'
    assert num_ticks > 0, 'num_ticks must be positive'
    assert tick_length > 0, 'tick_length must be positive'

    # Get the image height and width
    height, width = dst.shape[:2]

    # Create a 1D array of values ranging from min_value to max_value
    values = np.linspace(0, 255, 255)[::-1]

    # Apply the colormap to the values
    colorbar = cv2.applyColorMap(values.astype(np.uint8), cmap)

    # Resize the colorbar according to the orientation and size
    if orientation == 'vertical':
        colorbar = cv2.resize(colorbar, (int(width * size), height))
    else:
        colorbar = cv2.resize(colorbar, (width, int(height * size)))

    # Rotate the colorbar if horizontal
    if orientation == 'horizontal':
        colorbar = cv2.rotate(colorbar, cv2.ROTATE_90_CLOCKWISE)

    # Create a copy of the image
    image_copy = dst.copy()

    # Paste the colorbar on the image according to the position and margin
    if position == 'right':
        image_copy[:, -colorbar.shape[1] - margin:-margin, :] = colorbar
    elif position == 'left':
        image_copy[:, margin:margin + colorbar.shape[1], :] = colorbar
    elif position == 'top':
        image_copy[margin:margin + colorbar.shape[0], :, :] = colorbar
    else:
        image_copy[-colorbar.shape[0] - margin:-margin, :, :] = colorbar

    # Draw the min and max values on the image
    """
    if orientation == 'vertical':
        if position == 'right':
            x_min = width - colorbar.shape[1] - margin - 10
            x_max = x_min
        else:
            x_min = margin + colorbar.shape[1] + 10
            x_max = x_min
        y_min = height - margin
        y_max = margin
    else:
        if position == 'top':
            y_min = margin + colorbar.shape[0] + 10
            y_max = y_min
        else:
            y_min = height - margin - 10
            y_max = y_min
        x_min = margin
        x_max = width - margin
    cv2.putText(image_copy, str(min_value), (x_min, y_min), font, font_scale, font_color, thickness)
    cv2.putText(image_copy, str(max_value), (x_max, y_max), font, font_scale, font_color, thickness)
    """
    
    # Draw the ticks on the image
    tick_values = np.linspace(min_value, max_value, num_ticks)
    tick_positions = np.linspace(0, 255, num_ticks).astype(np.int32)
    if orientation == 'vertical':
        if position == 'right':
            x_start = width - colorbar.shape[1] - margin
            x_end = x_start - tick_length
        else:
            x_start = margin + colorbar.shape[1]
            x_end = x_start + tick_length
        for i in range(num_ticks):
            y = int(height - margin - tick_positions[i] * (height - 2 * margin) / 255)
            # cv2.line(image_copy, (x_start, y), (x_end, y), tick_color, thickness)
            cv2.putText(image_copy, '%.3g'%(tick_values[i]), (x_end - 10, y + 5), font, font_scale, tick_color, thickness)
    else:
        if position == 'top':
            y_start = margin + colorbar.shape[0]
            y_end = y_start + tick_length
        else:
            y_start = height - margin - colorbar.shape[0]
            y_end = y_start - tick_length
        for i in range(num_ticks):
            x = int(margin + tick_positions[i] * (width - 2 * margin) / 255)
            # cv2.line(image_copy, (x, y_start), (x, y_end), tick_color, thickness)
            cv2.putText(image_copy, '%.3g'%(tick_values[i]), (x - 5, y_end + 10), font, font_scale, tick_color, thickness)

    # Return the image with the colorbar
    return image_copy
